(function () {
'use strict';

var asyncGenerator = function () {
  function AwaitValue(value) {
    this.value = value;
  }

  function AsyncGenerator(gen) {
    var front, back;

    function send(key, arg) {
      return new Promise(function (resolve, reject) {
        var request = {
          key: key,
          arg: arg,
          resolve: resolve,
          reject: reject,
          next: null
        };

        if (back) {
          back = back.next = request;
        } else {
          front = back = request;
          resume(key, arg);
        }
      });
    }

    function resume(key, arg) {
      try {
        var result = gen[key](arg);
        var value = result.value;

        if (value instanceof AwaitValue) {
          Promise.resolve(value.value).then(function (arg) {
            resume("next", arg);
          }, function (arg) {
            resume("throw", arg);
          });
        } else {
          settle(result.done ? "return" : "normal", result.value);
        }
      } catch (err) {
        settle("throw", err);
      }
    }

    function settle(type, value) {
      switch (type) {
        case "return":
          front.resolve({
            value: value,
            done: true
          });
          break;

        case "throw":
          front.reject(value);
          break;

        default:
          front.resolve({
            value: value,
            done: false
          });
          break;
      }

      front = front.next;

      if (front) {
        resume(front.key, front.arg);
      } else {
        back = null;
      }
    }

    this._invoke = send;

    if (typeof gen.return !== "function") {
      this.return = undefined;
    }
  }

  if (typeof Symbol === "function" && Symbol.asyncIterator) {
    AsyncGenerator.prototype[Symbol.asyncIterator] = function () {
      return this;
    };
  }

  AsyncGenerator.prototype.next = function (arg) {
    return this._invoke("next", arg);
  };

  AsyncGenerator.prototype.throw = function (arg) {
    return this._invoke("throw", arg);
  };

  AsyncGenerator.prototype.return = function (arg) {
    return this._invoke("return", arg);
  };

  return {
    wrap: function (fn) {
      return function () {
        return new AsyncGenerator(fn.apply(this, arguments));
      };
    },
    await: function (value) {
      return new AwaitValue(value);
    }
  };
}();





var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();







var get = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;

    if (getter === undefined) {
      return undefined;
    }

    return getter.call(receiver);
  }
};

var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};











var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};



var set = function set(object, property, value, receiver) {
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent !== null) {
      set(parent, property, value, receiver);
    }
  } else if ("value" in desc && desc.writable) {
    desc.value = value;
  } else {
    var setter = desc.set;

    if (setter !== undefined) {
      setter.call(receiver, value);
    }
  }

  return value;
};

var Loop = function () {
    /**
     *
     */
    function Loop() {
        classCallCheck(this, Loop);

        this.loopTimer = null;
        this.loopFuncs = [];
    }

    /**
     * Add function to execute per tick.
     *
     * @param {Function} func
     */


    createClass(Loop, [{
        key: "onTick",
        value: function onTick(func) {
            this.loopFuncs.push(func.bind(this));
        }

        /**
         * Perform one iteration of the loop.
         */

    }, {
        key: "tick",
        value: function tick() {
            this.loopTimer = setTimeout(this.tick.bind(this), 20);
            this.loopFuncs.forEach(function (func) {
                func();
            });
        }

        /**
         * Start the loop.
         */

    }, {
        key: "start",
        value: function start() {
            if (this.loopTimer === null) {
                this.loopTimer = setTimeout(this.tick.bind(this), 20);
            }
        }

        /**
         * Stop the loop.
         */

    }, {
        key: "stop",
        value: function stop() {
            if (this.loopTimer !== null) {
                clearTimeout(this.loopTimer);
            }
        }
    }]);
    return Loop;
}();

var Shape = function () {

    /**
     * @param {{ posX: Number, posY: Number, angle: Number, speed: Number, gravity: Number, elasticity: Number, friction: Number }} data
     */
    function Shape() {
        var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { posX: 0, posY: 0, angle: 0, speed: 0, gravity: 0, elasticity: 0, friction: 0 };
        classCallCheck(this, Shape);

        this.init(data);
        this.setState(data);
    }

    /**
     * Get the state of the shape.
     *
     * @returns {{
     *      posX: Number,
     *      posY: Number,
     *      velX: Number,
     *      velY: Number,
     *      speed: Number,
     *      gravity: Number,
     *      elasticity: Number,
     *      friction: Number
     * }}
     */


    createClass(Shape, [{
        key: "getState",
        value: function getState() {
            return this.state;
        }

        /**
         * Set the state of the shape.
         *
         * @param {{
         *      posX: Number,
         *      posY: Number,
         *      velX: Number,
         *      velY: Number,
         *      speed: Number,
         *      gravity: Number,
         *      elasticity: Number,
         *      friction: Number
         * }} state
         */

    }, {
        key: "setState",
        value: function setState(state) {
            this.state = state;
        }

        /**
         * Get the specified param by key.
         *
         * @param {String} param
         * @returns {*}
         */

    }, {
        key: "getParam",
        value: function getParam(param) {
            return this.state[param];
        }

        /**
         * Set a value of specified param by key.
         *
         * @param param
         * @param value
         */

    }, {
        key: "setParam",
        value: function setParam(param, value) {
            this.state[param] = value;
        }

        /**
         * Init shape data.
         *
         * @param {*} data
         */

    }, {
        key: "init",
        value: function init(data) {}
        // to be inherited


        /**
         * Update shape position.
         *
         * @param {Element} canvas
         */

    }, {
        key: "update",
        value: function update(canvas) {}
        // to be inherited


        /**
         * Draw shape.
         *
         * @param {Element} ctx
         */

    }, {
        key: "draw",
        value: function draw(ctx) {
            // to be inherited
        }
    }]);
    return Shape;
}();

var Ball = function (_Shape) {
    inherits(Ball, _Shape);

    /**
     * @override
     */
    function Ball(data) {
        classCallCheck(this, Ball);
        return possibleConstructorReturn(this, (Ball.__proto__ || Object.getPrototypeOf(Ball)).call(this, data));
    }

    /**
     * @override
     */


    createClass(Ball, [{
        key: 'init',
        value: function init(data) {
            // translate angle to vector
            var radians = data.angle * Math.PI / 180;
            data.velX = Math.cos(radians) * data.speed;
            data.velY = Math.sin(radians) * data.speed;
        }

        /**
         * @override
         */

    }, {
        key: 'update',
        value: function update(canvas) {
            // get the current state of the ball
            var _getState = this.getState(),
                posX = _getState.posX,
                posY = _getState.posY,
                velX = _getState.velX,
                velY = _getState.velY,
                gravity = _getState.gravity,
                elasticity = _getState.elasticity,
                friction = _getState.friction;

            // apply friction and gravity


            velX -= velX * friction;
            velY += gravity;

            // make sure the friction won't start pushing the ball in reverse direction
            if (velX < friction && velX > -friction) {
                velX = 0;
            }

            // check vertical borders restrictions
            if (posX + 6 >= canvas.width) {
                posX = canvas.width - 6;
                velX = -velX;
            } else if (posX <= 0) {
                posX = 0;
                velX = -velX;
            }

            // check horizontal borders restrictions
            if (posY + 6 >= canvas.height) {
                posY = canvas.height - 6;
                velY = -velY * elasticity;
            } else if (posY <= 0) {
                posY = 0;
                velY = -velY * elasticity;
            }

            // set the new velocity
            this.setParam('velX', velX);
            this.setParam('velY', velY);

            // calculate new position
            posX += velX;
            posY += velY;

            // persist new position
            this.setParam('posX', posX);
            this.setParam('posY', posY);
        }

        /**
         * @override
         */

    }, {
        key: 'draw',
        value: function draw(ctx) {
            ctx.beginPath();
            ctx.arc(this.getParam('posX'), this.getParam('posY'), 3, 0, Math.PI * 2, false);
            ctx.fillStyle = 'blue';
            ctx.fill();
            ctx.closePath();
        }
    }]);
    return Ball;
}(Shape);

var Canvas = function () {
    /**
     * @param {Element} canvas
     * @param {Loop} loop
     */
    function Canvas(canvas, loop) {
        classCallCheck(this, Canvas);

        if (canvas.nodeName !== 'CANVAS') {
            throw new Error('Passed element which is not canvas.');
        }

        this.canvas = canvas;
        this.context = canvas.getContext("2d");
        this.objs = [];

        loop.onTick(this.draw.bind(this));
    }

    /**
     * Return canvas element.
     *
     * @returns {Element}
     */


    createClass(Canvas, [{
        key: 'getCanvas',
        value: function getCanvas() {
            return this.canvas;
        }

        /**
         * Return canvas' context.
         *
         * @returns {Element}
         */

    }, {
        key: 'getContext',
        value: function getContext() {
            return this.context;
        }

        /**
         * @param {*} shape
         */

    }, {
        key: 'addElement',
        value: function addElement(shape) {
            this.objs.push(shape);
        }

        /**
         *
         */

    }, {
        key: 'draw',
        value: function draw() {
            var canvas = this.canvas;
            var ctx = this.context;
            var w = canvas.width;
            var h = canvas.height;

            // Clean
            ctx.clearRect(0, 0, w, h);

            // Update Shapes
            this.objs.forEach(function (shape) {
                shape.update(canvas);
            });

            // Draw Shapes
            this.objs.forEach(function (shape) {
                shape.draw(ctx);
            });
        }
    }]);
    return Canvas;
}();

var App =
/**
 * @param {Array} args
 */
function App(args) {
    classCallCheck(this, App);

    var loop = new Loop();
    var canvas = new Canvas(args, loop);
    var context = canvas.getContext();

    canvas.getCanvas().addEventListener('click', function (e) {
        canvas.addElement.call(canvas, new Ball({
            posX: e.pageX,
            posY: e.pageY,
            angle: Math.floor(-Math.random() * 140 - 20),
            speed: Math.floor(2 + Math.random() * 8),
            gravity: 0.1,
            elasticity: 0.4,
            friction: 0.01
        }));
    }, false);

    loop.start();
};

/**
 * Run application after everything is loaded.
 */


window.addEventListener('load', function () {

    var canvas = document.getElementById('playground');
    canvas.height = window.innerHeight;
    canvas.width = window.innerWidth;
    window.app = new App(canvas);
}, false);

}());
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjpudWxsLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9Mb29wL0xvb3AuanMiLCIuLi8uLi9zcmMvQ2FudmFzL01vZGVsL1NoYXBlLmpzIiwiLi4vLi4vc3JjL0NhbnZhcy9Nb2RlbC9CYWxsLmpzIiwiLi4vLi4vc3JjL0NhbnZhcy9DYW52YXMuanMiLCIuLi8uLi9zcmMvYXBwLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjbGFzcyBMb29wXG57XG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpXG4gICAge1xuICAgICAgICB0aGlzLmxvb3BUaW1lciA9IG51bGw7XG4gICAgICAgIHRoaXMubG9vcEZ1bmNzID0gW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgcGVyIHRpY2suXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jXG4gICAgICovXG4gICAgb25UaWNrKGZ1bmMpXG4gICAge1xuICAgICAgICB0aGlzLmxvb3BGdW5jcy5wdXNoKGZ1bmMuYmluZCh0aGlzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybSBvbmUgaXRlcmF0aW9uIG9mIHRoZSBsb29wLlxuICAgICAqL1xuICAgIHRpY2soKVxuICAgIHtcbiAgICAgICAgdGhpcy5sb29wVGltZXIgPSBzZXRUaW1lb3V0KHRoaXMudGljay5iaW5kKHRoaXMpLCAyMCk7XG4gICAgICAgIHRoaXMubG9vcEZ1bmNzLmZvckVhY2goZnVuY3Rpb24oZnVuYykge1xuICAgICAgICAgICAgZnVuYygpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdGFydCB0aGUgbG9vcC5cbiAgICAgKi9cbiAgICBzdGFydCgpXG4gICAge1xuICAgICAgICBpZiAodGhpcy5sb29wVGltZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMubG9vcFRpbWVyID0gc2V0VGltZW91dCh0aGlzLnRpY2suYmluZCh0aGlzKSwgMjApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3RvcCB0aGUgbG9vcC5cbiAgICAgKi9cbiAgICBzdG9wKClcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLmxvb3BUaW1lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMubG9vcFRpbWVyKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsImV4cG9ydCBjbGFzcyBTaGFwZSB7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3sgcG9zWDogTnVtYmVyLCBwb3NZOiBOdW1iZXIsIGFuZ2xlOiBOdW1iZXIsIHNwZWVkOiBOdW1iZXIsIGdyYXZpdHk6IE51bWJlciwgZWxhc3RpY2l0eTogTnVtYmVyLCBmcmljdGlvbjogTnVtYmVyIH19IGRhdGFcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihkYXRhID0geyBwb3NYOiAwLCBwb3NZOiAwLCBhbmdsZTogMCwgc3BlZWQ6IDAsIGdyYXZpdHk6IDAsIGVsYXN0aWNpdHk6IDAsIGZyaWN0aW9uOiAwIH0pXG4gICAge1xuICAgICAgICB0aGlzLmluaXQoZGF0YSk7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoZGF0YSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBzdGF0ZSBvZiB0aGUgc2hhcGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7e1xuICAgICAqICAgICAgcG9zWDogTnVtYmVyLFxuICAgICAqICAgICAgcG9zWTogTnVtYmVyLFxuICAgICAqICAgICAgdmVsWDogTnVtYmVyLFxuICAgICAqICAgICAgdmVsWTogTnVtYmVyLFxuICAgICAqICAgICAgc3BlZWQ6IE51bWJlcixcbiAgICAgKiAgICAgIGdyYXZpdHk6IE51bWJlcixcbiAgICAgKiAgICAgIGVsYXN0aWNpdHk6IE51bWJlcixcbiAgICAgKiAgICAgIGZyaWN0aW9uOiBOdW1iZXJcbiAgICAgKiB9fVxuICAgICAqL1xuICAgIGdldFN0YXRlKClcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgc3RhdGUgb2YgdGhlIHNoYXBlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHt7XG4gICAgICogICAgICBwb3NYOiBOdW1iZXIsXG4gICAgICogICAgICBwb3NZOiBOdW1iZXIsXG4gICAgICogICAgICB2ZWxYOiBOdW1iZXIsXG4gICAgICogICAgICB2ZWxZOiBOdW1iZXIsXG4gICAgICogICAgICBzcGVlZDogTnVtYmVyLFxuICAgICAqICAgICAgZ3Jhdml0eTogTnVtYmVyLFxuICAgICAqICAgICAgZWxhc3RpY2l0eTogTnVtYmVyLFxuICAgICAqICAgICAgZnJpY3Rpb246IE51bWJlclxuICAgICAqIH19IHN0YXRlXG4gICAgICovXG4gICAgc2V0U3RhdGUoc3RhdGUpXG4gICAge1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBzcGVjaWZpZWQgcGFyYW0gYnkga2V5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZ2V0UGFyYW0ocGFyYW0pXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZVtwYXJhbV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IGEgdmFsdWUgb2Ygc3BlY2lmaWVkIHBhcmFtIGJ5IGtleS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbVxuICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAqL1xuICAgIHNldFBhcmFtKHBhcmFtLCB2YWx1ZSlcbiAgICB7XG4gICAgICAgIHRoaXMuc3RhdGVbcGFyYW1dID0gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdCBzaGFwZSBkYXRhLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSBkYXRhXG4gICAgICovXG4gICAgaW5pdChkYXRhKVxuICAgIHtcbiAgICAgICAgLy8gdG8gYmUgaW5oZXJpdGVkXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHNoYXBlIHBvc2l0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBjYW52YXNcbiAgICAgKi9cbiAgICB1cGRhdGUoY2FudmFzKVxuICAgIHtcbiAgICAgICAgLy8gdG8gYmUgaW5oZXJpdGVkXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRHJhdyBzaGFwZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gY3R4XG4gICAgICovXG4gICAgZHJhdyhjdHgpXG4gICAge1xuICAgICAgICAvLyB0byBiZSBpbmhlcml0ZWRcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBTaGFwZSB9IGZyb20gJy4vU2hhcGUnO1xuXG5leHBvcnQgY2xhc3MgQmFsbCBleHRlbmRzIFNoYXBlXG57XG4gICAgLyoqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZGF0YSlcbiAgICB7XG4gICAgICAgIHN1cGVyKGRhdGEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIGluaXQoZGF0YSlcbiAgICB7XG4gICAgICAgIC8vIHRyYW5zbGF0ZSBhbmdsZSB0byB2ZWN0b3JcbiAgICAgICAgdmFyIHJhZGlhbnMgPSBkYXRhLmFuZ2xlICogTWF0aC5QSSAvIDE4MDtcbiAgICAgICAgZGF0YS52ZWxYID0gTWF0aC5jb3MocmFkaWFucykgKiBkYXRhLnNwZWVkO1xuICAgICAgICBkYXRhLnZlbFkgPSBNYXRoLnNpbihyYWRpYW5zKSAqIGRhdGEuc3BlZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgdXBkYXRlKGNhbnZhcylcbiAgICB7XG4gICAgICAgIC8vIGdldCB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgYmFsbFxuICAgICAgICB2YXIgeyBwb3NYLCBwb3NZLCB2ZWxYLCB2ZWxZLCBncmF2aXR5LCBlbGFzdGljaXR5LCBmcmljdGlvbiB9ID0gdGhpcy5nZXRTdGF0ZSgpO1xuXG4gICAgICAgIC8vIGFwcGx5IGZyaWN0aW9uIGFuZCBncmF2aXR5XG4gICAgICAgIHZlbFggLT0gdmVsWCpmcmljdGlvbjtcbiAgICAgICAgdmVsWSArPSBncmF2aXR5O1xuXG4gICAgICAgIC8vIG1ha2Ugc3VyZSB0aGUgZnJpY3Rpb24gd29uJ3Qgc3RhcnQgcHVzaGluZyB0aGUgYmFsbCBpbiByZXZlcnNlIGRpcmVjdGlvblxuICAgICAgICBpZiAodmVsWCA8IGZyaWN0aW9uICYmIHZlbFggPiAtZnJpY3Rpb24pIHtcbiAgICAgICAgICAgIHZlbFggPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2hlY2sgdmVydGljYWwgYm9yZGVycyByZXN0cmljdGlvbnNcbiAgICAgICAgaWYgKHBvc1grNiA+PSBjYW52YXMud2lkdGgpIHtcbiAgICAgICAgICAgIHBvc1ggPSBjYW52YXMud2lkdGggLSA2O1xuICAgICAgICAgICAgdmVsWCA9IC12ZWxYO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBvc1ggPD0gMCkge1xuICAgICAgICAgICAgcG9zWCA9IDA7XG4gICAgICAgICAgICB2ZWxYID0gLXZlbFg7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjaGVjayBob3Jpem9udGFsIGJvcmRlcnMgcmVzdHJpY3Rpb25zXG4gICAgICAgIGlmIChwb3NZKzYgPj0gY2FudmFzLmhlaWdodCkge1xuICAgICAgICAgICAgcG9zWSA9IGNhbnZhcy5oZWlnaHQgLSA2O1xuICAgICAgICAgICAgdmVsWSA9IC12ZWxZICogZWxhc3RpY2l0eTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwb3NZIDw9IDApIHtcbiAgICAgICAgICAgIHBvc1kgPSAwO1xuICAgICAgICAgICAgdmVsWSA9IC12ZWxZICogZWxhc3RpY2l0eTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNldCB0aGUgbmV3IHZlbG9jaXR5XG4gICAgICAgIHRoaXMuc2V0UGFyYW0oJ3ZlbFgnLCB2ZWxYKTtcbiAgICAgICAgdGhpcy5zZXRQYXJhbSgndmVsWScsIHZlbFkpO1xuXG4gICAgICAgIC8vIGNhbGN1bGF0ZSBuZXcgcG9zaXRpb25cbiAgICAgICAgcG9zWCArPSB2ZWxYO1xuICAgICAgICBwb3NZICs9IHZlbFk7XG5cbiAgICAgICAgLy8gcGVyc2lzdCBuZXcgcG9zaXRpb25cbiAgICAgICAgdGhpcy5zZXRQYXJhbSgncG9zWCcsIHBvc1gpO1xuICAgICAgICB0aGlzLnNldFBhcmFtKCdwb3NZJywgcG9zWSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgZHJhdyhjdHgpXG4gICAge1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5hcmModGhpcy5nZXRQYXJhbSgncG9zWCcpLCB0aGlzLmdldFBhcmFtKCdwb3NZJyksIDMsIDAsIE1hdGguUEkqMiwgZmFsc2UpO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gJ2JsdWUnO1xuICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgQmFsbCB9IGZyb20gJy4vTW9kZWwvQmFsbCc7XG5cbmV4cG9ydCBjbGFzcyBDYW52YXNcbntcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGNhbnZhc1xuICAgICAqIEBwYXJhbSB7TG9vcH0gbG9vcFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNhbnZhcywgbG9vcClcbiAgICB7XG4gICAgICAgIGlmIChjYW52YXMubm9kZU5hbWUgIT09ICdDQU5WQVMnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Bhc3NlZCBlbGVtZW50IHdoaWNoIGlzIG5vdCBjYW52YXMuJyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgICAgdGhpcy5vYmpzID0gW107XG5cbiAgICAgICAgbG9vcC5vblRpY2sodGhpcy5kcmF3LmJpbmQodGhpcykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBjYW52YXMgZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtFbGVtZW50fVxuICAgICAqL1xuICAgIGdldENhbnZhcygpXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5jYW52YXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGNhbnZhcycgY29udGV4dC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtFbGVtZW50fVxuICAgICAqL1xuICAgIGdldENvbnRleHQoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyp9IHNoYXBlXG4gICAgICovXG4gICAgYWRkRWxlbWVudChzaGFwZSlcbiAgICB7XG4gICAgICAgIHRoaXMub2Jqcy5wdXNoKHNoYXBlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGRyYXcoKVxuICAgIHtcbiAgICAgICAgdmFyIGNhbnZhcyA9IHRoaXMuY2FudmFzO1xuICAgICAgICB2YXIgY3R4ID0gdGhpcy5jb250ZXh0O1xuICAgICAgICB2YXIgdyA9IGNhbnZhcy53aWR0aDtcbiAgICAgICAgdmFyIGggPSBjYW52YXMuaGVpZ2h0O1xuXG4gICAgICAgIC8vIENsZWFuXG4gICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgdywgaCk7XG5cbiAgICAgICAgLy8gVXBkYXRlIFNoYXBlc1xuICAgICAgICB0aGlzLm9ianMuZm9yRWFjaCgoc2hhcGUpID0+IHtcbiAgICAgICAgICAgIHNoYXBlLnVwZGF0ZShjYW52YXMpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBEcmF3IFNoYXBlc1xuICAgICAgICB0aGlzLm9ianMuZm9yRWFjaCgoc2hhcGUpID0+IHtcbiAgICAgICAgICAgIHNoYXBlLmRyYXcoY3R4KTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgTG9vcCB9IGZyb20gJy4vTG9vcC9Mb29wJztcbmltcG9ydCB7IENhbnZhcyB9IGZyb20gJy4vQ2FudmFzL0NhbnZhcyc7XG5pbXBvcnQgeyBCYWxsIH0gZnJvbSAnLi9DYW52YXMvTW9kZWwvQmFsbCc7XG5cbmNsYXNzIEFwcFxue1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyZ3NcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihhcmdzKVxuICAgIHtcbiAgICAgICAgdmFyIGxvb3AgPSBuZXcgTG9vcCgpO1xuICAgICAgICB2YXIgY2FudmFzID0gbmV3IENhbnZhcyhhcmdzLCBsb29wKTtcbiAgICAgICAgdmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgpO1xuXG4gICAgICAgIGNhbnZhcy5nZXRDYW52YXMoKS5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICAgICAgJ2NsaWNrJyxcbiAgICAgICAgICAgIChlKSA9PiB7XG4gICAgICAgICAgICAgICAgY2FudmFzLmFkZEVsZW1lbnQuY2FsbChjYW52YXMsIG5ldyBCYWxsKHtcbiAgICAgICAgICAgICAgICAgICAgcG9zWDogZS5wYWdlWCxcbiAgICAgICAgICAgICAgICAgICAgcG9zWTogZS5wYWdlWSxcbiAgICAgICAgICAgICAgICAgICAgYW5nbGU6IE1hdGguZmxvb3IoLU1hdGgucmFuZG9tKCkqMTQwLTIwKSxcbiAgICAgICAgICAgICAgICAgICAgc3BlZWQ6IE1hdGguZmxvb3IoMitNYXRoLnJhbmRvbSgpKjgpLFxuICAgICAgICAgICAgICAgICAgICBncmF2aXR5OiAwLjEsXG4gICAgICAgICAgICAgICAgICAgIGVsYXN0aWNpdHk6IDAuNCxcbiAgICAgICAgICAgICAgICAgICAgZnJpY3Rpb246IDAuMDFcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgKTtcblxuICAgICAgICBsb29wLnN0YXJ0KCk7XG4gICAgfVxufVxuXG4vKipcbiAqIFJ1biBhcHBsaWNhdGlvbiBhZnRlciBldmVyeXRoaW5nIGlzIGxvYWRlZC5cbiAqL1xud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCAoKSA9PiB7XG5cbiAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3BsYXlncm91bmQnKTtcbiAgICBjYW52YXMuaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0O1xuICAgIGNhbnZhcy53aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgIHdpbmRvdy5hcHAgPSBuZXcgQXBwKGNhbnZhcyk7XG5cbn0sIGZhbHNlKTtcbiJdLCJuYW1lcyI6WyJMb29wIiwibG9vcFRpbWVyIiwibG9vcEZ1bmNzIiwiZnVuYyIsInB1c2giLCJiaW5kIiwic2V0VGltZW91dCIsInRpY2siLCJmb3JFYWNoIiwiU2hhcGUiLCJkYXRhIiwicG9zWCIsInBvc1kiLCJhbmdsZSIsInNwZWVkIiwiZ3Jhdml0eSIsImVsYXN0aWNpdHkiLCJmcmljdGlvbiIsImluaXQiLCJzZXRTdGF0ZSIsInN0YXRlIiwicGFyYW0iLCJ2YWx1ZSIsImNhbnZhcyIsImN0eCIsIkJhbGwiLCJyYWRpYW5zIiwiTWF0aCIsIlBJIiwidmVsWCIsImNvcyIsInZlbFkiLCJzaW4iLCJnZXRTdGF0ZSIsIndpZHRoIiwiaGVpZ2h0Iiwic2V0UGFyYW0iLCJiZWdpblBhdGgiLCJhcmMiLCJnZXRQYXJhbSIsImZpbGxTdHlsZSIsImZpbGwiLCJjbG9zZVBhdGgiLCJDYW52YXMiLCJsb29wIiwibm9kZU5hbWUiLCJFcnJvciIsImNvbnRleHQiLCJnZXRDb250ZXh0Iiwib2JqcyIsIm9uVGljayIsImRyYXciLCJzaGFwZSIsInciLCJoIiwiY2xlYXJSZWN0IiwidXBkYXRlIiwiQXBwIiwiYXJncyIsImdldENhbnZhcyIsImFkZEV2ZW50TGlzdGVuZXIiLCJlIiwiYWRkRWxlbWVudCIsImNhbGwiLCJwYWdlWCIsInBhZ2VZIiwiZmxvb3IiLCJyYW5kb20iLCJzdGFydCIsIndpbmRvdyIsImRvY3VtZW50IiwiZ2V0RWxlbWVudEJ5SWQiLCJpbm5lckhlaWdodCIsImlubmVyV2lkdGgiLCJhcHAiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBQWFBLElBQWI7Ozs7b0JBTUk7OzthQUNTQyxTQUFMLEdBQWlCLElBQWpCO2FBQ0tDLFNBQUwsR0FBaUIsRUFBakI7Ozs7Ozs7Ozs7OzsrQkFRR0MsSUFoQlgsRUFpQkk7aUJBQ1NELFNBQUwsQ0FBZUUsSUFBZixDQUFvQkQsS0FBS0UsSUFBTCxDQUFVLElBQVYsQ0FBcEI7Ozs7Ozs7OzsrQkFPSjtpQkFDU0osU0FBTCxHQUFpQkssV0FBVyxLQUFLQyxJQUFMLENBQVVGLElBQVYsQ0FBZSxJQUFmLENBQVgsRUFBaUMsRUFBakMsQ0FBakI7aUJBQ0tILFNBQUwsQ0FBZU0sT0FBZixDQUF1QixVQUFTTCxJQUFULEVBQWU7O2FBQXRDOzs7Ozs7Ozs7Z0NBU0o7Z0JBQ1EsS0FBS0YsU0FBTCxLQUFtQixJQUF2QixFQUE2QjtxQkFDcEJBLFNBQUwsR0FBaUJLLFdBQVcsS0FBS0MsSUFBTCxDQUFVRixJQUFWLENBQWUsSUFBZixDQUFYLEVBQWlDLEVBQWpDLENBQWpCOzs7Ozs7Ozs7OytCQVFSO2dCQUNRLEtBQUtKLFNB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
